## 首部校验和算法

假设发送方发送的是五个 4 位数的序列 `{7, 11, 12, 0, 6}`，除了发送这几个数外还要发送这几个数的和 36。接收方把五个数相加，并将结果于和进行比较，相同则认为没有差错。

上面的方法存在一个问题，就是如果校验和也是 4 位，那么是放不下 36 的。因此采用二进制反码加法：
```
36 = 0b10_0100 => 0b10 + 0b0100 = 0b0110 = 6 
```
接收方同样采用二进制反码加法计算校验和，结果同样是 6 则认为没有差错。

为了使接收方的计算更简单，发送方将二进制反码加法求得和 6 取反，0110 => 1001 作为校验和放在首部中。接收方只需要按照每 4 位使用二进制反码加法求和，正常情况下结果为 1111，然后取反判断是不是等于 0 即可完成校验。

传统上，因特网使用一个 16 位的校验和。  
发送方逻辑：    
```
1. 报文被划分为 16 位的字。

2. 校验和的值初始化为 0。  

3. 用二进制反码加法把所有的字相加，包括校验和。// 一般和用 32 位保存，溢出的位可以右移 16 位得到，右边的 16 位可以和 0x0000FFFF 进行与运算得到

4. 对和求反，从而形成校验和。 // 32 位截断为 16 位得到校验和

5. 校验和随数据一起发送。  
```

接收方逻辑：  
```
1. 报文被划分为 16 位的字。

2. 用二进制反码加法把所有的字相加。 
 
3. 对和求反，从而生成新的校验和。
 
4. 如果校验和的值是 0，报文被接受，否则，报文被拒绝。  
```

二进制反码加法求得的和不可能全部为 0，因此校验和字段正常情况下不可能全部为 1。
## 为什么 TCP 和 UDP 的校验和计算时要增加伪首部部分
伪首部包含
- 源 IP 地址
- 目的 IP 地址：防止数据包被错误的送达，如果 IP 在传输过程中目的地址发生了改变，IP 的校验和算法并不一定能够检测出来。
- 运输层协议



## TCP 的缓存和窗口的关系

有 4 和缓存，客户端的发送和接收缓存，服务器的发送和接收缓存。需要注意的时它们都是和 Scoket 一一对应的，并不是操作系统全局唯一的。

## 全双工、半双工和单工

**全双工 Full Duplex**，是指在同一时间，数据可以同时双向传输，即通信的两个端点可以同时发送和接收数据而不会发生碰撞。

**半双工 Half Duplex**，是指在同一时间，数据只能在一个方向上传输。虽然通信的两个端点都可以发送和接收数据，但不能同时进行。例如，对讲机和无线电通信就是半双工。

**单工 Simplex**，是指数据只能在一个方向上传输，并且只能由一个设备发送数据，另一个设备只能接收数据。

## TCP 能不能传输超过 4GB 的数据

肯定是可以的。

首先虽然 TCP 的序号为 32 位，但是序号的主要目的表示字节的顺序，其次才是标识唯一一个字节，序号的值在达到最大值之后将回到 0。

如果接收方的缓存大于 4GB，那么发送端不就无法弄明白接收方的确认是针对哪一个字节的了吗？接收方的缓存大小即窗口大小，而窗口大小字段是 16 位的，不会超过 65535 字节。所以问题不存在。（当然，64KB 的窗口大小对于现在计算机来说太小了，因此 TCP 引入了 TCP 窗口缩放选项作为窗口缩放的比例因子，来扩大窗口的大小。）

## TCP 纯的 ACK 报文段不消耗序号

TCP 中的纯 ACK 报文段不消耗序号。

在 TCP 协议中，ACK 报文段用于确认已经成功接收到的数据。当接收方收到数据后，会发送一个 ACK 报文段给发送方，以确认接收到的数据。这个 ACK 报文段通常不包含任何数据，只有一个确认号字段，用来指示下一个期望接收的数据的序号。

因此，纯 ACK 报文段不携带数据，也不消耗序号，它们只是用来进行流量控制和确认数据接收