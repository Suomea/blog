Base64 算法最早应用于电子邮件传输问题。早期由于历史问题，电子邮件只允许 ASCII 字符码。如果要传输一封带有非 ACSII 字符码的电子邮件，
早期的历史问题可能会导致乱码，于是 Base64——一种能够将二进制数据转换为 ASCII 字符码的算法应运而生。

## Base64 字符转换表
Base64 算法能够将二进制的数据转换为 64 个 ACSII 字符（加上填充字符 '=' 共 65 个）， 参考[RFC 4648](https://www.rfc-editor.org/rfc/rfc4648.html#page-5) 。
```
+------+--------+------+-------+--------+------+-------+--------+------+-------+--------+------+
|Index | Binary | Char | Index | Binary | Char | Index | Binary | Char | Index | Binary | Char |
|------+--------+------+-------+--------+------+-------+--------+------+-------+--------+------|
|0     | 000000 | A    | 16    | 010000 | Q    | 32    | 100000 | g    | 48    | 110000 | w    |
|1     | 000001 | B    | 17    | 010001 | R    | 33    | 100001 | h    | 49    | 110001 | x    |
|2     | 000010 | C    | 18    | 010010 | S    | 34    | 100010 | i    | 50    | 110010 | y    |
|3     | 000011 | D    | 19    | 010011 | T    | 35    | 100011 | j    | 51    | 110011 | z    |
|4     | 000100 | E    | 20    | 010100 | U    | 36    | 100100 | k    | 52    | 110100 | 0    |
|5     | 000101 | F    | 21    | 010101 | V    | 37    | 100101 | l    | 53    | 110101 | 1    |
|6     | 000110 | G    | 22    | 010110 | W    | 38    | 100110 | m    | 54    | 110110 | 2    |
|7     | 000111 | H    | 23    | 010111 | X    | 39    | 100111 | n    | 55    | 110111 | 3    |
|8     | 001000 | I    | 24    | 011000 | Y    | 40    | 101000 | o    | 56    | 111000 | 4    |
|9     | 001001 | J    | 25    | 011001 | Z    | 41    | 101001 | p    | 57    | 111001 | 5    |
|10    | 001010 | K    | 26    | 011010 | a    | 42    | 101010 | q    | 58    | 111010 | 6    |
|11    | 001011 | L    | 27    | 011011 | b    | 43    | 101011 | r    | 59    | 111011 | 7    |
|12    | 001100 | M    | 28    | 011100 | c    | 44    | 101100 | s    | 60    | 111100 | 8    |
|13    | 001101 | N    | 29    | 011101 | d    | 45    | 101101 | t    | 61    | 111101 | 9    |
|14    | 001110 | O    | 30    | 011110 | e    | 46    | 101110 | u    | 62    | 111110 | +    |
|15    | 001111 | P    | 31    | 011111 | f    | 47    | 101111 | v    | 63    | 111111 | /    |
+------+--------+------+-------+--------+------+-------+--------+------+-------+--------+------+
Padding (=)
```
## 转换规则
1. 获得字符串的二进制编码。

2. 将二进制编码进行分组，每 24 位为一段，每段再分为 6 位一组（不够 6 位的地位补 0，没有位的组，结果中使用填充字符 '='）。

3. 向每组的高两位补 0 组成 8 位。

4. 将获得的 4 组二进制码转换为 10 进制。

5. 将获得的十进制码参照 Base64 字符对照表转换成对应的字符。


**示例 1.** 字符串二进制位数刚好为 24 的整数倍 "yes"

	1) 对应的字节数组为 {121, 101, 115} 转换为二进制：01111001 01100101 01110011

	2) 分成 6 位一组：011110 010110 010101 110011

	3) 高位补 0：00011110 00010110 00010101 00110011

	4) 对应的十进制：30 22 21 51

	5) 结果：eWVz

**示例 2.** 字符串二进制位数不为 24 的整数倍 "y"

	1) 对应的字节数组为 {121} 转换为二进制：01111001

	2) 分成 6 位一组，不够的位补 0：011110 010000

	3) 高位补 0：00011110 00010000 padding padding

	4) 对应的十进制：30 8 padding padding

	5) 结果：eQ==

一般 Base64 结果的字符串最多会有两个填充字符，因为数据的二进制通常码以字节为单位（8bit）存储，保证至少会有两个组（6bit）。

## UrlBase64 算法
UrlBase64 算法主要是替换了 Base64 字符映射表中的第 62 和 63 个字符，也就是将 `+` 和 `/` 替换成 `-` 和 `_` 。

## 示例代码
```java
public class Test {
    public static void main(String[] args) {
        byte[] data  = "你好世界！@#￥%……&*（）".getBytes(StandardCharsets.UTF_8);

        Base64.getEncoder().encodeToString(data);

        Base64.getEncoder().withoutPadding().encodeToString(data);

        Base64.getUrlEncoder().encodeToString(data);

        Base64.getUrlEncoder().withoutPadding().encodeToString(data);
    }
}
```