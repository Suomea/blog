## 分析类的能力

### 获取类的信息
在 java.lang.reflect 包中有三个类 Field、Method 和 Constructor 分别用于描述类的字段、方法和构造函数。

- `Class getDeclaringClass()` 返回定义了构造函数、方法或字段的类。
- `Class[] getExceptionTypes()` 在 Constructor 和 Method 类中。返回构造函数或者方法所抛出的异常类型。
- `int getModifiers()` 返回一个整数，描述构造函数、方法或者字段的修饰符。使用 Modifier 类中的方法来分析这个返回值。
- `String getName()` 返回表示构造函数、方法或字段名称的字符串。
- `Class[] getParameterTypes()` 在 Constructor 和 Method 类中。返回构造函数或者方法参数的类型。
- `Class getReturnType()` 在 Method 类中。返回表示返回类型的 Class 对象。

java.lang.Class 类提供了以下函数获取类的信息。

- `String getPackageName()` 返回类型的包名。如果是数组类型则返回数组元素所属的包，如果是基本类型则返回 `java.lang`。
- `Constructor[] getConstructors()` 返回当前类中所有 public 构造函数，包括从父类继承的 public 构造函数。
- `Constructor[] getDeclaredConstructors()` 反回当前类声明的所有构造函数，不论其访问修饰符，但不包括从父类继承的构造函数。
- `Method[] getMethods()` 返回当前类声明的所有 public 方法，包括从父类继承的 public 方法。
- `Method[] getDeclaredMethods()` 反回当前类声明的所有方法，不论其访问修饰符，但不包括从父类继承的方法。
- `Field[] getFields()` 返回当前类声明的所有 public 字段，包括从父类继承的 public 字段。
- `Field[] getDeclaredFields()` 反回当前类声明的所有字段，不论其访问修饰符，但不包括从父类继承的字段。

打印类的构造函数，方法和字段。
```java
package com.otto.reflective;  
  
import java.lang.reflect.Constructor;  
import java.lang.reflect.Field;  
import java.lang.reflect.Method;  
import java.lang.reflect.Modifier;  
import java.util.Scanner;  
  
public class ReflectiveTest {  
  
    public static final String TEST_FIELD = "hello world";  
  
    public static void main(String[] args) throws ReflectiveOperationException{  
        String name;  
        if (args.length > 0)  
            name = args[0];  
        else {  
            System.out.println("Enter class name(e.g. java.util.Date): ");  
            name = new Scanner(System.in).next();  
        }  
  
        Class clz = Class.forName(name);  
  
        // 获取类的修饰符，例如 public final        
        String modifiers = Modifier.toString(clz.getModifiers());  
        if (modifiers.length() > 0)  
            System.out.print(modifiers + " ");  
  
        // 获取类的父类  
        Class superClz = clz.getSuperclass();  
        System.out.print("class " + name);  
        if (superClz != null && superClz != Object.class)  
            System.out.print(" extends " + superClz.getName());  
  
        System.out.print("\n{\n");  
  
        printConstructors(clz);  
        System.out.println();  
  
        printMethods(clz);  
        System.out.println();  
  
        printFields(clz);  
        System.out.println("}");  
    }  
  
    public static void printConstructors(Class clz) {  
        Constructor[] constructors = clz.getDeclaredConstructors();  
  
        for (Constructor c : constructors) {  
            // 获取构造函数名称  
            String name = c.getName();  
            System.out.print("  ");  
  
            // 打印构造函数的修饰符  
            String modifiers = Modifier.toString(c.getModifiers());  
            if (modifiers.length() > 0)  
                System.out.print(modifiers + " ");  
  
            // 打印参数列表  
            System.out.print(name + "(");  
            Class[] paramTypes = c.getParameterTypes();  
            for (int j = 0; j < paramTypes.length; j ++){  
                if (j > 0)  
                    System.out.print(", ");  
                System.out.print(paramTypes[j].getName());  
            }  
            System.out.println(");");  
        }  
    }  
  
    public static void printMethods(Class clz) {  
        Method[] methods = clz.getDeclaredMethods();  
  
        for (Method m : methods){  
            // 获取方法返回类型和方法名称  
            Class retType = m.getReturnType();  
            String name = m.getName();  
            System.out.print("  ");  
  
            // 打印方法修饰符  
            String modifiers = Modifier.toString(m.getModifiers());  
            if (modifiers.length() > 0)  
                System.out.print(modifiers + "  ");  
  
            // 打印方法返回类型和方法名称  
            System.out.print(retType.getName() + " " + name + "(");  
  
            // 打印方法参数类型列表  
            Class[] paramTypes = m.getParameterTypes();  
            for (int j = 0; j < paramTypes.length; j ++) {  
                if (j > 0)  
                    System.out.print(", ");  
                System.out.print(paramTypes[j].getName());  
            }  
            System.out.println(");");  
        }  
    }  
  
    public static void printFields(Class clz) {  
        Field[] fields = clz.getDeclaredFields();  
  
        for (Field f : fields) {  
            // 获取属性类型和属性名称  
            Class type = f.getType();  
            String name = f.getName();  
            System.out.print("  ");  
  
            // 打印属性修饰符  
            String modifiers = Modifier.toString(f.getModifiers());  
            if (modifiers.length() > 0)  
                System.out.print(modifiers + " ");  
  
            // 打印属性名称  
            System.out.println(type.getName() + " " + name + ";");  
        }  
    }  
}
```

Java 8 开始，反射 API 提供了获取参数名称的功能，但是需要在编译时开启 --parameters 选项
```java
package com.otto.reflective;

import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.lang.reflect.Parameter;

public class ParameterNameTest {
    public static void main(String[] args) throws NoSuchMethodException {
        Class clz = ParameterNameTest.class;

        Method m = clz.getDeclaredMethod("testMethod", String.class);

        Parameter[] parameters = m.getParameters();
        String paramType = parameters[0].getType().getName();
        String paramName = parameters[0].getName();

        String modifier = Modifier.toString(m.getModifiers());

        System.out.println(modifier + " "
                + m.getReturnType().getName() + " "
                + m.getName()
                + "(" + paramType + " " + paramName + ")"
        ); // private void testMethod(java.lang.String testParam)
    }

    private void testMethod(String testParam) {

    }
}

```

### 动态地操作对象

用于测试的类
```java
package com.otto.reflective;

public class ReflectiveObjectTest {

    public String field1 = "hello";

    private int field2 = 1;

    public ReflectiveObjectTest() {
    }

    private ReflectiveObjectTest(String field1, int field2) {
        this.field1 = field1;
        this.field2 = field2;
    }

    private void printMsg(String msg) {
        System.out.println(String.format("(%s, %d) got message: %s", field1, field2, msg));
    }
}
```

测试代码
```java
package com.otto.reflective;  
  
import java.lang.reflect.Constructor;  
import java.lang.reflect.Field;  
import java.lang.reflect.Method;  
  
public class App {  
    public static void main(String[] args) throws Exception{  
  
        Class clz = ReflectiveObjectTest.class;  
  
        // 获取默认的构造函数生成对象  
        ReflectiveObjectTest obj1 = (ReflectiveObjectTest) clz.getDeclaredConstructor().newInstance();  
  
        // 获取属性 field1 的值  
        Field f1 = clz.getDeclaredField("field1");  
        System.out.println(f1.get(obj1));    // hello  
  
        // 获取属性 field2 的值  
        Field f2 = clz.getDeclaredField("field2");  
            // 设置属性的可访问标志  
        f2.setAccessible(true);  
        System.out.println(f2.get(obj1));    // 1  
        // 修改 field2 的值  
        f2.set(obj1, 2);  
        System.out.println(f2.get(obj1));    // 2  
  
        // 获取有参的构造函数  
        Constructor declaredConstructor = clz.getDeclaredConstructor(String.class, int.class);  
            // 设置构造函数的可访问标志  
        declaredConstructor.setAccessible(true);  
        // 使用有参的构造函数生成对象  
        ReflectiveObjectTest obj2 = (ReflectiveObjectTest) declaredConstructor.newInstance("nihao", 2);  
          
        // 获取有参的方法  
        Method m = clz.getDeclaredMethod("printMsg", String.class);  
        // 设置方法的可访问标志  
        m.setAccessible(true);  
        // 使用反射执行方法  
        m.invoke(obj2, "-_-");  // (nihao, 2) got message: -_-  
    }  
}
```

反射机制的默认行为受限与 Java 的访问控制。不过，可以调用 Constructor、Method 和 Field 对象的 setAccessible 方法覆盖 Java 的访问控制。
## QA
验证所有的类都是在对其第一次使用时动态加载到 JVM 中的。

准备代码
```java
package com.otto.reflective;

import java.util.Scanner;

public class App 
{
    public static void main( String[] args )
    {
        Scanner scanner = new Scanner(System.in);
        while (scanner.hasNext()) {
            String next = scanner.next();
            switch (next) {
                case "one" :
                    new TestLoadOne().testPrint();
                    break;
                case "two":
                    new TestLoadTwo().testPrint();
                    break;
                case "exit":
                    System.exit(0);
                default:
                    break;
            }
        }
    }
}
```

使用 arthas 调试查看已经加载的类，查看 App、TestLoadOne 和 TestLoadTwo 的加载时机。
```
java -jar arthas-boot.jar
> sc *otto*
```

结论：程序启动后默认会加载 App 类，输入 one 之后加载 TestLoadOne 类，输入 two 之后加载 TestLoadTwo 类。

获取类的所有方法，不包括 Object 集成而来的方法。
```java
  private Method[] getClassMethods(Class<?> clazz) {
    Map<String, Method> uniqueMethods = new HashMap<>();
    Class<?> currentClass = clazz;
    while (currentClass != null && currentClass != Object.class) {
      // 由于 getMethods() 方法只会返回 public 修饰的方法，
      // 所以这里使用 getDeclaredMethods() + 循环的方式获取所有的方法
      addUniqueMethods(uniqueMethods, currentClass.getDeclaredMethods());

      // 获取所有实现接口的方法接口都是 public 的
      Class<?>[] interfaces = currentClass.getInterfaces();
      for (Class<?> anInterface : interfaces) {
        addUniqueMethods(uniqueMethods, anInterface.getMethods());
      }

      currentClass = currentClass.getSuperclass();
    }

    Collection<Method> methods = uniqueMethods.values();

    return methods.toArray(new Method[0]);
  }

  private void addUniqueMethods(Map<String, Method> uniqueMethods, Method[] methods) {
    for (Method currentMethod : methods) {
      // 桥接方法是编译器在类型擦除时确保类型安全生成的方法，忽略掉
      if (!currentMethod.isBridge()) { 
        String signature = getSignature(currentMethod);
        if (!uniqueMethods.containsKey(signature)) {
          uniqueMethods.put(signature, currentMethod);
        }
      }
    }
  }
  
  // 生成方法签名，类似 
  private String getSignature(Method method) {
    StringBuilder sb = new StringBuilder();
    Class<?> returnType = method.getReturnType();
    sb.append(returnType.getName()).append('#');
    sb.append(method.getName());
    Class<?>[] parameters = method.getParameterTypes();
    for (int i = 0; i < parameters.length; i++) {
      sb.append(i == 0 ? ':' : ',').append(parameters[i].getName());
    }
    return sb.toString();
  }
```